#!/usr/bin/env ruby

require 'eventmachine'
require 'httparty'
require 'digest'
require 'json'
require 'cgi'
require 'base64'

require './lib/torrent/transmission'

def mkchunks(io, chunk_size)
  chunks = ""

  while (chunk = io.read(chunk_size))
    chunks += Digest::SHA1.digest(chunk)
  end

  chunks
end

def magnetize(name, info_hash)
  "magnet:?xt=urn:btih:#{info_hash}&dn=#{CGI.escape(name)}"
end

def infodict(name, io)
  chunk_size = 32768
  chunks = mkchunks(io, chunk_size)

  {
    "length" => io.size,
    "name" => name,
    "piece length" => chunk_size,
    "pieces" => chunks,
    "private" => 0
  }
end

def torrentize(infodict)
  {"info" => infodict}
end

class Service
  include HTTParty
  headers 'Content-Type' => "application/json"
  base_uri "http://localhost:4567"
  format :json
end

class Manager
  def initialize
    @torrents = []
    @trans = Transmission.new("config/transmission")
    puts "--- " + @trans.inspect
  end

  def status
    @trans.status @torrents
  end

  def publish(file)
    name = File.basename(file)
    io = File.open(file, 'rb')
    info = infodict(name, io)
    torrent = torrentize(info)

    info_hash = Digest::SHA1.hexdigest(info.bencode)
    torrent = Base64::encode64(torrentize(info).bencode)

    # Start seeding the file.
    resp = @trans.add_seed(torrent, File.dirname(file))
    id = resp["torrent-added"]["id"]
    @torrents << id

    info["pieces"] = Base64::encode64(info["pieces"])
    Service.post("/files", :query => {:client_id => Process.pid}, :body => info.to_json)
  end

  def download(magnets)
    magnets.each do |magnet|
      puts "adding #{magnet.inspect} to download list"
      response = @trans.add magnet
      puts "added #{response}"
    end
  end
end

def poll_for_updates(manager)
  puts "-- polling for changes"

  resp = Service.get("/files", :query => {:client_id => Process.pid})
  manager.download(JSON.parse(resp.body))
end

module DeliveryServer
  def initialize(manager)
    @manager = manager
  end

  def post_init
    puts "-- client connected"
  end

  def receive_data(data)
    path = data

    # Yes, yes, publishing blocks. We're not trying for perf for now.
    # TODO: Use a non-blocking http client.
    @manager.publish(path.strip)

    close_connection
  end

  def unbind
    puts "-- client disconnected"
  end
end

EM.run do
  manager = Manager.new
  timer = EM::PeriodicTimer.new(5) { poll_for_updates(manager) }
  status_checks = EM::PeriodicTimer.new(5) { puts manager.status.inspect }

  EM.start_server "127.0.0.1", 1225, DeliveryServer, manager
end
